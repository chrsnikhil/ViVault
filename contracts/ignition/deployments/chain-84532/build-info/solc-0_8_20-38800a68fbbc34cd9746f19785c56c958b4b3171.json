{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-38800a68fbbc34cd9746f19785c56c958b4b3171",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/VaultFactory.sol": "project/contracts/VaultFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": ["ast"],
          "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata"]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "project/contracts/UserVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title UserVault\r\n * @notice Individual user's token vault with strategy settings\r\n * @dev Stores rebalancing strategy preferences and handles token custody\r\n */\r\ncontract UserVault {\r\n    using SafeERC20 for IERC20;\r\n    \r\n    // Immutable state\r\n    address public immutable owner;\r\n    address public immutable factory;\r\n    \r\n    // Strategy configuration\r\n    struct RebalanceStrategy {\r\n        uint256 highVolatilityThreshold;   // e.g., 70 (out of 100)\r\n        uint256 lowVolatilityThreshold;    // e.g., 30 (out of 100)\r\n        TokenAllocation[] highVolAllocation;\r\n        TokenAllocation[] lowVolAllocation;\r\n    }\r\n    \r\n    struct TokenAllocation {\r\n        address token;\r\n        uint256 percentage;  // Out of 100\r\n    }\r\n    \r\n    RebalanceStrategy private _strategy;\r\n    bool public strategyInitialized;\r\n    \r\n    // Events\r\n    event StrategyUpdated(\r\n        uint256 highThreshold,\r\n        uint256 lowThreshold,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event TokensReceived(\r\n        address indexed token,\r\n        uint256 amount,\r\n        address indexed from,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event TokensWithdrawn(\r\n        address indexed token,\r\n        uint256 amount,\r\n        address indexed to,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event EmergencyWithdraw(\r\n        address indexed token,\r\n        uint256 amount,\r\n        address indexed to,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    // Errors\r\n    error NotVaultOwner();\r\n    error InvalidThresholds();\r\n    error ThresholdOutOfRange();\r\n    error InvalidAllocation();\r\n    error InvalidToken();\r\n    error InvalidRecipient();\r\n    error StrategyNotInitialized();\r\n    error ZeroAmount();\r\n    \r\n    constructor(address _owner) {\r\n        if (_owner == address(0)) revert InvalidRecipient();\r\n        owner = _owner;\r\n        factory = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) revert NotVaultOwner();\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @notice Sets the rebalancing strategy for this vault\r\n     * @param highThreshold Volatility level to trigger risk-off (0-100)\r\n     * @param lowThreshold Volatility level to trigger risk-on (0-100)\r\n     * @param highAlloc Token allocation for high volatility\r\n     * @param lowAlloc Token allocation for low volatility\r\n     */\r\n    function setStrategy(\r\n        uint256 highThreshold,\r\n        uint256 lowThreshold,\r\n        TokenAllocation[] memory highAlloc,\r\n        TokenAllocation[] memory lowAlloc\r\n    ) external onlyOwner {\r\n        if (highThreshold <= lowThreshold) revert InvalidThresholds();\r\n        if (highThreshold > 100 || lowThreshold > 100) revert ThresholdOutOfRange();\r\n        if (!_validateAllocations(highAlloc)) revert InvalidAllocation();\r\n        if (!_validateAllocations(lowAlloc)) revert InvalidAllocation();\r\n        \r\n        // Clear old allocations\r\n        delete _strategy.highVolAllocation;\r\n        delete _strategy.lowVolAllocation;\r\n        \r\n        // Set thresholds\r\n        _strategy.highVolatilityThreshold = highThreshold;\r\n        _strategy.lowVolatilityThreshold = lowThreshold;\r\n        \r\n        // Set allocations\r\n        for (uint i = 0; i < highAlloc.length; i++) {\r\n            _strategy.highVolAllocation.push(highAlloc[i]);\r\n        }\r\n        \r\n        for (uint i = 0; i < lowAlloc.length; i++) {\r\n            _strategy.lowVolAllocation.push(lowAlloc[i]);\r\n        }\r\n        \r\n        strategyInitialized = true;\r\n        \r\n        emit StrategyUpdated(highThreshold, lowThreshold, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Validates token allocations\r\n     * @param allocations Array of token allocations\r\n     * @return True if valid, false otherwise\r\n     */\r\n    function _validateAllocations(\r\n        TokenAllocation[] memory allocations\r\n    ) internal pure returns (bool) {\r\n        if (allocations.length == 0) return false;\r\n        \r\n        uint256 totalPercentage = 0;\r\n        for (uint i = 0; i < allocations.length; i++) {\r\n            if (allocations[i].token == address(0)) return false;\r\n            totalPercentage += allocations[i].percentage;\r\n        }\r\n        \r\n        return totalPercentage == 100;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get vault's balance of a specific token\r\n     * @param token The token address\r\n     * @return The token balance\r\n     */\r\n    function getBalance(address token) external view returns (uint256) {\r\n        return IERC20(token).balanceOf(address(this));\r\n    }\r\n    \r\n    /**\r\n     * @notice Get balances for multiple tokens\r\n     * @param tokens Array of token addresses\r\n     * @return balances Array of corresponding balances\r\n     */\r\n    function getBalances(address[] calldata tokens) external view returns (uint256[] memory balances) {\r\n        balances = new uint256[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            balances[i] = IERC20(tokens[i]).balanceOf(address(this));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Get total balance of a specific token\r\n     * @param token The token address\r\n     * @return The total balance of the token in the vault\r\n     */\r\n    function getTotalBalance(address token) external view returns (uint256) {\r\n        return IERC20(token).balanceOf(address(this));\r\n    }\r\n    \r\n    /**\r\n     * @notice Check if vault has any balance of a token\r\n     * @param token The token address\r\n     * @return True if vault has balance, false otherwise\r\n     */\r\n    function hasBalance(address token) external view returns (bool) {\r\n        return IERC20(token).balanceOf(address(this)) > 0;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get the complete strategy configuration\r\n     * @return highThreshold High volatility threshold\r\n     * @return lowThreshold Low volatility threshold\r\n     * @return highAlloc High volatility allocation\r\n     * @return lowAlloc Low volatility allocation\r\n     */\r\n    function getStrategy() external view returns (\r\n        uint256 highThreshold,\r\n        uint256 lowThreshold,\r\n        TokenAllocation[] memory highAlloc,\r\n        TokenAllocation[] memory lowAlloc\r\n    ) {\r\n        return (\r\n            _strategy.highVolatilityThreshold,\r\n            _strategy.lowVolatilityThreshold,\r\n            _strategy.highVolAllocation,\r\n            _strategy.lowVolAllocation\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Get strategy thresholds\r\n     * @return highThreshold High volatility threshold\r\n     * @return lowThreshold Low volatility threshold\r\n     */\r\n    function getStrategyThresholds() external view returns (uint256 highThreshold, uint256 lowThreshold) {\r\n        return (_strategy.highVolatilityThreshold, _strategy.lowVolatilityThreshold);\r\n    }\r\n    \r\n    /**\r\n     * @notice Get allocation for a specific volatility level\r\n     * @param isHighVolatility True for high volatility allocation, false for low\r\n     * @return allocations Array of token allocations\r\n     */\r\n    function getAllocation(bool isHighVolatility) external view returns (TokenAllocation[] memory allocations) {\r\n        if (isHighVolatility) {\r\n            return _strategy.highVolAllocation;\r\n        } else {\r\n            return _strategy.lowVolAllocation;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Deposit tokens into vault (owner only)\r\n     * @dev Users deposit tokens from their wallet to the vault\r\n     * @param token The token address\r\n     * @param amount The amount to deposit\r\n     */\r\n    function deposit(address token, uint256 amount) external onlyOwner {\r\n        if (token == address(0)) revert InvalidToken();\r\n        if (amount == 0) revert ZeroAmount();\r\n        \r\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\r\n        \r\n        emit TokensReceived(token, amount, msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Withdraw tokens from vault (owner only)\r\n     * @dev Users withdraw tokens from vault back to their wallet\r\n     * @param token The token address\r\n     * @param amount The amount to withdraw\r\n     */\r\n    function withdraw(address token, uint256 amount) external onlyOwner {\r\n        if (token == address(0)) revert InvalidToken();\r\n        if (amount == 0) revert ZeroAmount();\r\n        \r\n        IERC20(token).safeTransfer(msg.sender, amount);\r\n        \r\n        emit TokensWithdrawn(token, amount, msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Withdraw tokens from vault to specific recipient (owner only)\r\n     * @dev This is the ONLY way tokens leave the vault besides Vincent swaps\r\n     * @param token The token address\r\n     * @param amount The amount to withdraw\r\n     * @param recipient The recipient address\r\n     */\r\n    function withdrawTo(\r\n        address token,\r\n        uint256 amount,\r\n        address recipient\r\n    ) external onlyOwner {\r\n        if (recipient == address(0)) revert InvalidRecipient();\r\n        if (token == address(0)) revert InvalidToken();\r\n        if (amount == 0) revert ZeroAmount();\r\n        \r\n        IERC20(token).safeTransfer(recipient, amount);\r\n        \r\n        emit TokensWithdrawn(token, amount, recipient, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency withdraw all tokens (owner only)\r\n     * @param tokens Array of token addresses to withdraw\r\n     */\r\n    function emergencyWithdrawAll(address[] calldata tokens) external onlyOwner {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            if (tokens[i] == address(0)) continue;\r\n            \r\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\r\n            if (balance > 0) {\r\n                IERC20(tokens[i]).safeTransfer(owner, balance);\r\n                emit EmergencyWithdraw(tokens[i], balance, owner, block.timestamp);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Check if strategy is initialized\r\n     * @return True if strategy is set, false otherwise\r\n     */\r\n    function isStrategyInitialized() external view returns (bool) {\r\n        return strategyInitialized;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get vault summary information\r\n     * @return ownerAddress The vault owner\r\n     * @return factoryAddress The factory address\r\n     * @return initialized Whether strategy is initialized\r\n     * @return highThreshold High volatility threshold\r\n     * @return lowThreshold Low volatility threshold\r\n     */\r\n    function getVaultInfo() external view returns (\r\n        address ownerAddress,\r\n        address factoryAddress,\r\n        bool initialized,\r\n        uint256 highThreshold,\r\n        uint256 lowThreshold\r\n    ) {\r\n        return (\r\n            owner,\r\n            factory,\r\n            strategyInitialized,\r\n            _strategy.highVolatilityThreshold,\r\n            _strategy.lowVolatilityThreshold\r\n        );\r\n    }\r\n    \r\n    // Receive function to accept ERC20 transfers\r\n    // Vincent Abilities will transfer tokens here\r\n    receive() external payable {}\r\n}"
      },
      "project/contracts/VaultFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./UserVault.sol\";\r\n\r\n/**\r\n * @title VaultFactory\r\n * @notice Factory contract for deploying individual user vaults\r\n * @dev Implements factory pattern for isolated user custody\r\n */\r\ncontract VaultFactory {\r\n    // State variables\r\n    mapping(address => address) public userVaults;\r\n    address[] public allVaults;\r\n    address public owner;\r\n    \r\n    // Events\r\n    event VaultCreated(address indexed user, address indexed vault, uint256 timestamp);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    // Errors\r\n    error VaultAlreadyExists(address user);\r\n    error NotOwner();\r\n    error ZeroAddress();\r\n    \r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) revert NotOwner();\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @notice Creates a new vault for the caller\r\n     * @return vaultAddress The address of the newly created vault\r\n     */\r\n    function createVault() external returns (address vaultAddress) {\r\n        if (userVaults[msg.sender] != address(0)) {\r\n            revert VaultAlreadyExists(msg.sender);\r\n        }\r\n        \r\n        UserVault vault = new UserVault(msg.sender);\r\n        userVaults[msg.sender] = address(vault);\r\n        allVaults.push(address(vault));\r\n        \r\n        emit VaultCreated(msg.sender, address(vault), block.timestamp);\r\n        return address(vault);\r\n    }\r\n    \r\n    /**\r\n     * @notice Get vault address for a specific user\r\n     * @param user The user address\r\n     * @return The vault address (address(0) if no vault exists)\r\n     */\r\n    function getVault(address user) external view returns (address) {\r\n        return userVaults[user];\r\n    }\r\n    \r\n    /**\r\n     * @notice Get all deployed vault addresses\r\n     * @return Array of all vault addresses\r\n     */\r\n    function getAllVaults() external view returns (address[] memory) {\r\n        return allVaults;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get total number of deployed vaults\r\n     * @return The count of deployed vaults\r\n     */\r\n    function getVaultCount() external view returns (uint256) {\r\n        return allVaults.length;\r\n    }\r\n    \r\n    /**\r\n     * @notice Check if a user has a vault\r\n     * @param user The user address\r\n     * @return True if user has a vault, false otherwise\r\n     */\r\n    function hasVault(address user) external view returns (bool) {\r\n        return userVaults[user] != address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Transfer ownership of the factory\r\n     * @param newOwner The new owner address\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        if (newOwner == address(0)) revert ZeroAddress();\r\n        \r\n        address oldOwner = owner;\r\n        owner = newOwner;\r\n        \r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n    \r\n    /**\r\n     * @notice Get vault information for a user\r\n     * @param user The user address\r\n     * @return vaultAddress The vault address\r\n     * @return exists Whether the vault exists\r\n     */\r\n    function getVaultInfo(address user) external view returns (address vaultAddress, bool exists) {\r\n        vaultAddress = userVaults[user];\r\n        exists = vaultAddress != address(0);\r\n    }\r\n}"
      }
    }
  }
}
